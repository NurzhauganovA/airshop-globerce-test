# Generated by ariadne-codegen on 2025-09-18 16:35
# Source: app/graphql/queries

from typing import Any, Dict, List, Optional, Union

from .add_lines_to_checkout import AddLinesToCheckout
from .add_product_to_channel import AddProductToChannel
from .add_shipping_method_to_channel import AddShippingMethodToChannel
from .add_variant_stock import AddVariantStock
from .async_base_client import AsyncBaseClient
from .base_model import UNSET, UnsetType
from .channels_list import ChannelsList
from .create_checkout_for_customer import CreateCheckoutForCustomer
from .create_checkout_from_airlink import CreateCheckoutFromAirlink
from .create_order_from_saleor_checkout import CreateOrderFromSaleorCheckout
from .create_product_for_merchant import CreateProductForMerchant
from .create_shipping_price import CreateShippingPrice
from .create_shipping_zone_for_merchant import CreateShippingZoneForMerchant
from .create_transaction_for_order import CreateTransactionForOrder
from .create_variant_for_product import CreateVariantForProduct
from .create_warehouse import CreateWarehouse
from .delete_checkout_line import DeleteCheckoutLine
from .delete_checkout_lines import DeleteCheckoutLines
from .delete_shipping_zone_by_id import DeleteShippingZoneByID
from .delete_warehouse_by_id import DeleteWarehouseByID
from .display_avaiable_categories import DisplayAvaiableCategories
from .enums import CountryCode
from .full_fill_order import FullFillOrder
from .get_channel_by_id import GetChannelByID
from .get_customer_checkouts_by_id import GetCustomerCheckoutsByID
from .get_full_checkout_by_id import GetFullCheckoutByID
from .get_order_by_id import GetOrderByID
from .get_order_list import GetOrderList
from .get_product import GetProduct
from .get_shipping_zone_info_by_id import GetShippingZoneInfoByID
from .get_warehouse_by_id import GetWarehouseByID
from .get_warehouse_with_stocks import GetWarehouseWithStocks
from .get_warehouses import GetWarehouses
from .input_types import (
    CategorySortingInput,
    CategoryWhereInput,
    ChannelUpdateInput,
    CheckoutLineInput,
    OrderFilterInput,
    OrderFulfillLineInput,
    OrderSortingInput,
    ProductFilterInput,
    ProductOrder,
    ProductWhereInput,
    ShippingMethodChannelListingAddInput,
    ShippingZoneCreateInput,
    StockInput,
    TransactionCreateInput,
    WarehouseCreateInput,
    WarehouseFilterInput,
    WarehouseSortingInput,
    WarehouseUpdateInput,
)
from .list_products_by_merchant import ListProductsByMerchant
from .list_products_with_all_filters import ListProductsWithAllFilters
from .list_warehouses_by_i_ds import ListWarehousesByIDs
from .order_confirm_from_merchant import OrderConfirmFromMerchant
from .set_shipping_method_for_checkout import SetShippingMethodForCheckout
from .update_channel import UpdateChannel
from .update_checkout_addresses import UpdateCheckoutAddresses
from .update_checkout_email import UpdateCheckoutEmail
from .update_shipping_zone import UpdateShippingZone
from .update_warehouse import UpdateWarehouse
from .variant_set_price import VariantSetPrice


def gql(q: str) -> str:
    return q


class SaleorClient(AsyncBaseClient):
    async def add_lines_to_checkout(
        self, checkout_id: str, lines: List[CheckoutLineInput], **kwargs: Any
    ) -> AddLinesToCheckout:
        query = gql(
            """
            mutation addLinesToCheckout($checkoutId: ID!, $lines: [CheckoutLineInput!]!) {
              checkoutLinesAdd(lines: $lines, id: $checkoutId) {
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                checkoutErrors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"checkoutId": checkout_id, "lines": lines}
        response = await self.execute(
            query=query,
            operation_name="addLinesToCheckout",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return AddLinesToCheckout.model_validate(data)

    async def add_product_to_channel(
        self, product_id: str, chanel_id: str, **kwargs: Any
    ) -> AddProductToChannel:
        query = gql(
            """
            mutation addProductToChannel($productId: ID!, $chanelId: ID!) {
              productChannelListingUpdate(
                id: $productId
                input: {updateChannels: {channelId: $chanelId, isPublished: true, isAvailableForPurchase: true}}
              ) {
                product {
                  id
                  seoTitle
                  seoDescription
                  name
                  description
                  slug
                  created
                  updatedAt
                  chargeTaxes
                  rating
                  channel
                  descriptionJson
                  isAvailable
                  availableForPurchase
                  availableForPurchaseAt
                  isAvailableForPurchase
                  externalReference
                }
                errors {
                  field
                  message
                  code
                  attributes
                  values
                  channels
                  variants
                }
                productChannelListingErrors {
                  field
                  message
                  code
                  attributes
                  values
                  channels
                  variants
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"productId": product_id, "chanelId": chanel_id}
        response = await self.execute(
            query=query,
            operation_name="addProductToChannel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return AddProductToChannel.model_validate(data)

    async def add_shipping_method_to_channel(
        self,
        ship_met_id: str,
        shipping_method_channels_list: List[ShippingMethodChannelListingAddInput],
        **kwargs: Any
    ) -> AddShippingMethodToChannel:
        query = gql(
            """
            mutation addShippingMethodToChannel($shipMetId: ID!, $shippingMethodChannelsList: [ShippingMethodChannelListingAddInput!]!) {
              shippingMethodChannelListingUpdate(
                id: $shipMetId
                input: {addChannels: $shippingMethodChannelsList}
              ) {
                shippingMethod {
                  id
                  privateMetafields
                  metafields
                  name
                  description
                  type
                  maximumDeliveryDays
                  minimumDeliveryDays
                  maximumOrderPrice {
                    currency
                    amount
                  }
                  minimumOrderPrice {
                    currency
                    amount
                  }
                  channelListings {
                    id
                    channel {
                      id
                      name
                    }
                    maximumOrderPrice {
                      currency
                      amount
                    }
                    minimumOrderPrice {
                      currency
                      amount
                    }
                    price {
                      currency
                      amount
                    }
                  }
                }
                shippingErrors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                errors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "shipMetId": ship_met_id,
            "shippingMethodChannelsList": shipping_method_channels_list,
        }
        response = await self.execute(
            query=query,
            operation_name="addShippingMethodToChannel",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return AddShippingMethodToChannel.model_validate(data)

    async def add_variant_stock(
        self, stocks: List[StockInput], variant_id: str, **kwargs: Any
    ) -> AddVariantStock:
        query = gql(
            """
            mutation addVariantStock($stocks: [StockInput!]!, $variantId: ID!) {
              productVariantStocksCreate(stocks: $stocks, variantId: $variantId) {
                bulkStockErrors {
                  field
                  message
                  code
                  attributes
                  values
                  index
                }
                errors {
                  field
                  message
                  code
                  attributes
                  values
                  index
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"stocks": stocks, "variantId": variant_id}
        response = await self.execute(
            query=query, operation_name="addVariantStock", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return AddVariantStock.model_validate(data)

    async def update_channel(
        self, channel_id: str, channel_update_input: ChannelUpdateInput, **kwargs: Any
    ) -> UpdateChannel:
        query = gql(
            """
            mutation updateChannel($channelId: ID!, $channelUpdateInput: ChannelUpdateInput!) {
              channelUpdate(id: $channelId, input: $channelUpdateInput) {
                channelErrors {
                  field
                  message
                  code
                  shippingZones
                  warehouses
                }
                errors {
                  field
                  message
                  code
                  shippingZones
                  warehouses
                }
                channel {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "channelId": channel_id,
            "channelUpdateInput": channel_update_input,
        }
        response = await self.execute(
            query=query, operation_name="updateChannel", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return UpdateChannel.model_validate(data)

    async def channels_list(self, **kwargs: Any) -> ChannelsList:
        query = gql(
            """
            query channelsList {
              channels {
                id
                slug
                name
                isActive
                currencyCode
                hasOrders
                privateMetadata {
                  key
                  value
                }
                metadata {
                  key
                  value
                }
                paymentSettings {
                  defaultTransactionFlowStrategy
                  releaseFundsForExpiredCheckouts
                  checkoutTtlBeforeReleasingFunds
                  checkoutReleaseFundsCutOffDate
                }
                orderSettings {
                  automaticallyConfirmAllNewOrders
                  automaticallyFulfillNonShippableGiftCard
                  expireOrdersAfter
                  markAsPaidStrategy
                  deleteExpiredOrdersAfter
                  allowUnpaidOrders
                  includeDraftOrderInVoucherUsage
                  draftOrderLinePriceFreezePeriod
                  useLegacyLineDiscountPropagation
                }
                checkoutSettings {
                  useLegacyErrorFlow
                  automaticallyCompleteFullyPaidCheckouts
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {}
        response = await self.execute(
            query=query, operation_name="channelsList", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return ChannelsList.model_validate(data)

    async def create_checkout_for_customer(
        self,
        lines: List[CheckoutLineInput],
        customer_id: str,
        channel_slug: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateCheckoutForCustomer:
        query = gql(
            """
            mutation createCheckoutForCustomer($lines: [CheckoutLineInput!]!, $channelSlug: String, $customer_id: String!) {
              checkoutCreate(
                input: {lines: $lines, channel: $channelSlug, metadata: {key: "customer_id", value: $customer_id}}
              ) {
                created
                checkoutErrors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                checkout {
                  id
                  created
                  updatedAt
                  lastChange
                  voucherCode
                  email
                  lines {
                    id
                    quantity
                    requiresShipping
                    isGift
                    variant {
                      id
                      name
                      sku
                      trackInventory
                      quantityLimitPerCustomer
                      channel
                      margin
                      quantityOrdered
                      quantityAvailable
                      created
                      updatedAt
                      externalReference
                      channelListings {
                        id
                        price {
                          currency
                          amount
                        }
                      }
                      product {
                        id
                        name
                      }
                    }
                  }
                  totalPrice {
                    currency
                    gross {
                      currency
                      amount
                    }
                  }
                  subtotalPrice {
                    currency
                    gross {
                      currency
                      amount
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "lines": lines,
            "channelSlug": channel_slug,
            "customer_id": customer_id,
        }
        response = await self.execute(
            query=query,
            operation_name="createCheckoutForCustomer",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateCheckoutForCustomer.model_validate(data)

    async def create_checkout_from_airlink(
        self,
        variant_id: str,
        customer_id: str,
        airlink_id: str,
        channel_slug: Union[Optional[str], UnsetType] = UNSET,
        price: Union[Optional[Any], UnsetType] = UNSET,
        email: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateCheckoutFromAirlink:
        query = gql(
            """
            mutation createCheckoutFromAirlink($channelSlug: String, $variantId: ID!, $price: PositiveDecimal, $email: String, $customerId: String!, $airlinkId: String!) {
              checkoutCreate(
                input: {channel: $channelSlug, lines: {quantity: 1, variantId: $variantId, price: $price}, email: $email, shippingAddress: {skipValidation: true, country: KZ, city: "Airlink", streetAddress1: "Airlink"}, billingAddress: {country: KZ, skipValidation: true, city: "Airlink", streetAddress1: "Airlink"}, metadata: [{key: "customer_id", value: $customerId}, {key: "airlinkId", value: $airlinkId}]}
              ) {
                created
                checkoutErrors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                checkout {
                  id
                }
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "channelSlug": channel_slug,
            "variantId": variant_id,
            "price": price,
            "email": email,
            "customerId": customer_id,
            "airlinkId": airlink_id,
        }
        response = await self.execute(
            query=query,
            operation_name="createCheckoutFromAirlink",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateCheckoutFromAirlink.model_validate(data)

    async def create_order_from_saleor_checkout(
        self, checkout_id: str, merchant_id: str, **kwargs: Any
    ) -> CreateOrderFromSaleorCheckout:
        query = gql(
            """
            mutation createOrderFromSaleorCheckout($checkoutId: ID!, $merchantId: String!) {
              orderCreateFromCheckout(
                id: $checkoutId
                metadata: [{key: "merchant_id", value: $merchantId}]
              ) {
                order {
                  id
                  created
                  updatedAt
                  status
                  trackingClientId
                  shippingMethodName
                  collectionPointName
                  number
                  original
                  origin
                  isPaid
                  paymentStatus
                  paymentStatusDisplay
                  authorizeStatus
                  chargeStatus
                  taxExemption
                  shippingTaxRate
                  shippingTaxClassName
                  token
                  voucherCode
                  customerNote
                  redirectUrl
                  statusDisplay
                  canFinalize
                  userEmail
                  isShippingRequired
                  languageCode
                  languageCodeEnum
                  discountName
                  translatedDiscountName
                  displayGrossPrices
                  externalReference
                  checkoutId
                }
                errors {
                  field
                  message
                  code
                  variants
                  lines
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "checkoutId": checkout_id,
            "merchantId": merchant_id,
        }
        response = await self.execute(
            query=query,
            operation_name="createOrderFromSaleorCheckout",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateOrderFromSaleorCheckout.model_validate(data)

    async def create_product_for_merchant(
        self,
        product_type: str,
        merchant_id: str,
        category: Union[Optional[str], UnsetType] = UNSET,
        name: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateProductForMerchant:
        query = gql(
            """
            mutation CreateProductForMerchant($category: ID, $name: String, $product_type: ID!, $merchantId: String!) {
              productCreate(
                input: {category: $category, name: $name, productType: $product_type, metadata: [{key: "merchant_id", value: $merchantId}]}
              ) {
                productErrors {
                  field
                  message
                  code
                  attributes
                  values
                }
                errors {
                  field
                  message
                  code
                  attributes
                  values
                }
                product {
                  id
                  name
                  slug
                  metadata {
                    value
                    key
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "category": category,
            "name": name,
            "product_type": product_type,
            "merchantId": merchant_id,
        }
        response = await self.execute(
            query=query,
            operation_name="CreateProductForMerchant",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateProductForMerchant.model_validate(data)

    async def create_shipping_price(
        self,
        sz_id: str,
        name: Union[Optional[str], UnsetType] = UNSET,
        maximum_delivery_days: Union[Optional[int], UnsetType] = UNSET,
        minimum_delivery_days: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateShippingPrice:
        query = gql(
            """
            mutation createShippingPrice($name: String, $maximumDeliveryDays: Int, $minimumDeliveryDays: Int, $szId: ID!) {
              shippingPriceCreate(
                input: {name: $name, maximumDeliveryDays: $maximumDeliveryDays, minimumDeliveryDays: $minimumDeliveryDays, type: PRICE, shippingZone: $szId}
              ) {
                shippingErrors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                errors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                shippingMethod {
                  id
                  name
                  description
                  type
                  maximumDeliveryDays
                  minimumDeliveryDays
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "name": name,
            "maximumDeliveryDays": maximum_delivery_days,
            "minimumDeliveryDays": minimum_delivery_days,
            "szId": sz_id,
        }
        response = await self.execute(
            query=query,
            operation_name="createShippingPrice",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateShippingPrice.model_validate(data)

    async def create_shipping_zone_for_merchant(
        self, create_shipping_zone_input: ShippingZoneCreateInput, **kwargs: Any
    ) -> CreateShippingZoneForMerchant:
        query = gql(
            """
            mutation createShippingZoneForMerchant($createShippingZoneInput: ShippingZoneCreateInput!) {
              shippingZoneCreate(input: $createShippingZoneInput) {
                errors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                shippingErrors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                shippingZone {
                  id
                  privateMetafields
                  metafields
                  name
                  default
                  description
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "createShippingZoneInput": create_shipping_zone_input
        }
        response = await self.execute(
            query=query,
            operation_name="createShippingZoneForMerchant",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateShippingZoneForMerchant.model_validate(data)

    async def create_transaction_for_order(
        self, order_id: str, transaction_input: TransactionCreateInput, **kwargs: Any
    ) -> CreateTransactionForOrder:
        query = gql(
            """
            mutation createTransactionForOrder($orderId: ID!, $transactionInput: TransactionCreateInput!) {
              transactionCreate(id: $orderId, transaction: $transactionInput) {
                errors {
                  field
                  message
                  code
                }
                transaction {
                  id
                  privateMetafields
                  metafields
                  token
                  createdAt
                  modifiedAt
                  actions
                  name
                  message
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "orderId": order_id,
            "transactionInput": transaction_input,
        }
        response = await self.execute(
            query=query,
            operation_name="createTransactionForOrder",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateTransactionForOrder.model_validate(data)

    async def create_warehouse(
        self, input: WarehouseCreateInput, **kwargs: Any
    ) -> CreateWarehouse:
        query = gql(
            """
            mutation createWarehouse($input: WarehouseCreateInput!) {
              createWarehouse(input: $input) {
                errors {
                  field
                  message
                  code
                  shippingZones
                }
                warehouseErrors {
                  field
                  message
                  code
                  shippingZones
                }
                warehouse {
                  id
                  name
                  slug
                  email
                  isPrivate
                  companyName
                  clickAndCollectOption
                  externalReference
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input}
        response = await self.execute(
            query=query, operation_name="createWarehouse", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return CreateWarehouse.model_validate(data)

    async def delete_checkout_line(
        self, checkout_id: str, line_id: str, **kwargs: Any
    ) -> DeleteCheckoutLine:
        query = gql(
            """
            mutation deleteCheckoutLine($checkoutId: ID!, $lineId: ID!) {
              checkoutLineDelete(id: $checkoutId, lineId: $lineId) {
                checkout {
                  id
                  created
                  updatedAt
                  lastChange
                  email
                  isShippingRequired
                  quantity
                  stockReservationExpires
                  taxExemption
                  token
                  languageCode
                  displayGrossPrices
                  authorizeStatus
                  chargeStatus
                  lines {
                    id
                    quantity
                    requiresShipping
                    isGift
                    totalPrice {
                      currency
                      gross {
                        currency
                        amount
                      }
                    }
                  }
                }
                checkoutErrors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"checkoutId": checkout_id, "lineId": line_id}
        response = await self.execute(
            query=query,
            operation_name="deleteCheckoutLine",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteCheckoutLine.model_validate(data)

    async def delete_checkout_lines(
        self, checkout_id: str, line_ids: List[str], **kwargs: Any
    ) -> DeleteCheckoutLines:
        query = gql(
            """
            mutation deleteCheckoutLines($checkoutId: ID!, $lineIds: [ID!]!) {
              checkoutLinesDelete(linesIds: $lineIds, id: $checkoutId) {
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"checkoutId": checkout_id, "lineIds": line_ids}
        response = await self.execute(
            query=query,
            operation_name="deleteCheckoutLines",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteCheckoutLines.model_validate(data)

    async def delete_shipping_zone_by_id(
        self, shipping_zone_id: str, **kwargs: Any
    ) -> DeleteShippingZoneByID:
        query = gql(
            """
            mutation deleteShippingZoneByID($shippingZoneID: ID!) {
              shippingZoneDelete(id: $shippingZoneID) {
                shippingErrors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                errors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"shippingZoneID": shipping_zone_id}
        response = await self.execute(
            query=query,
            operation_name="deleteShippingZoneByID",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteShippingZoneByID.model_validate(data)

    async def delete_warehouse_by_id(
        self, warehouse_id: str, **kwargs: Any
    ) -> DeleteWarehouseByID:
        query = gql(
            """
            mutation deleteWarehouseByID($warehouseId: ID!) {
              deleteWarehouse(id: $warehouseId) {
                warehouseErrors {
                  field
                  message
                  code
                  shippingZones
                }
                errors {
                  field
                  message
                  code
                  shippingZones
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"warehouseId": warehouse_id}
        response = await self.execute(
            query=query,
            operation_name="deleteWarehouseByID",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DeleteWarehouseByID.model_validate(data)

    async def display_avaiable_categories(
        self,
        where: Union[Optional[CategoryWhereInput], UnsetType] = UNSET,
        sort_by: Union[Optional[CategorySortingInput], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        level: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> DisplayAvaiableCategories:
        query = gql(
            """
            query displayAvaiableCategories($where: CategoryWhereInput, $sortBy: CategorySortingInput, $first: Int, $after: String, $before: String, $last: Int, $level: Int) {
              categories(
                where: $where
                sortBy: $sortBy
                first: $first
                after: $after
                before: $before
                last: $last
                level: $level
              ) {
                totalCount
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
                edges {
                  cursor
                  node {
                    id
                    seoTitle
                    seoDescription
                    name
                    description
                    slug
                    level
                    descriptionJson
                    updatedAt
                    parent {
                      id
                      seoTitle
                      seoDescription
                      name
                      description
                      slug
                      level
                      descriptionJson
                      updatedAt
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "where": where,
            "sortBy": sort_by,
            "first": first,
            "after": after,
            "before": before,
            "last": last,
            "level": level,
        }
        response = await self.execute(
            query=query,
            operation_name="displayAvaiableCategories",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return DisplayAvaiableCategories.model_validate(data)

    async def full_fill_order(
        self,
        lines: List[OrderFulfillLineInput],
        order_id: str,
        allow_stock_to_be_exceeded: Union[Optional[bool], UnsetType] = UNSET,
        tracking_number: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> FullFillOrder:
        query = gql(
            """
            mutation fullFillOrder($lines: [OrderFulfillLineInput!]!, $allowStockToBeExceeded: Boolean, $trackingNumber: String, $orderId: ID!) {
              orderFulfill(
                input: {lines: $lines, allowStockToBeExceeded: $allowStockToBeExceeded, trackingNumber: $trackingNumber}
                order: $orderId
              ) {
                fulfillments {
                  id
                  fulfillmentOrder
                  status
                  trackingNumber
                  created
                  statusDisplay
                }
                orderErrors {
                  field
                  message
                  code
                  warehouse
                  orderLines
                  variants
                  addressType
                }
                errors {
                  field
                  message
                  code
                  warehouse
                  orderLines
                  variants
                  addressType
                }
                order {
                  id
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "lines": lines,
            "allowStockToBeExceeded": allow_stock_to_be_exceeded,
            "trackingNumber": tracking_number,
            "orderId": order_id,
        }
        response = await self.execute(
            query=query, operation_name="fullFillOrder", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return FullFillOrder.model_validate(data)

    async def get_channel_by_id(self, channel_id: str, **kwargs: Any) -> GetChannelByID:
        query = gql(
            """
            query getChannelByID($channelId: ID!) {
              channel(id: $channelId) {
                id
                slug
                name
                isActive
                currencyCode
                hasOrders
              }
            }
            """
        )
        variables: Dict[str, object] = {"channelId": channel_id}
        response = await self.execute(
            query=query, operation_name="getChannelByID", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetChannelByID.model_validate(data)

    async def get_customer_checkouts_by_id(
        self, customer_id: str, **kwargs: Any
    ) -> GetCustomerCheckoutsByID:
        query = gql(
            """
            query getCustomerCheckoutsByID($customer_id: String!) {
              checkouts(
                last: 30
                filter: {metadata: {key: "customer_id", value: $customer_id}}
              ) {
                totalCount
                edges {
                  cursor
                  node {
                    id
                    created
                    updatedAt
                    lastChange
                    customerNote
                    note
                    discountName
                    translatedDiscountName
                    email
                    isShippingRequired
                    quantity
                    stockReservationExpires
                    taxExemption
                    token
                    languageCode
                    displayGrossPrices
                    authorizeStatus
                    chargeStatus
                    channel {
                      id
                      slug
                      name
                      isActive
                      currencyCode
                      hasOrders
                    }
                    lines {
                      id
                      quantity
                      requiresShipping
                      isGift
                      variant {
                        id
                        name
                        sku
                        margin
                        quantityOrdered
                        quantityAvailable
                        created
                        updatedAt
                        externalReference
                        channelListings {
                          id
                          price {
                            currency
                            amount
                          }
                        }
                        product {
                          id
                          seoTitle
                          seoDescription
                          name
                          description
                          slug
                          created
                          updatedAt
                          chargeTaxes
                          rating
                          channel
                          descriptionJson
                          isAvailable
                          availableForPurchase
                          availableForPurchaseAt
                          isAvailableForPurchase
                          externalReference
                        }
                        weight {
                          unit
                          value
                        }
                        images {
                          id
                          alt
                          sortOrder
                          url
                        }
                        media {
                          id
                          sortOrder
                          alt
                          type
                          oembedData
                          url
                          productId
                        }
                      }
                    }
                    subtotalPrice {
                      currency
                      gross {
                        currency
                        amount
                      }
                    }
                    totalPrice {
                      currency
                      gross {
                        currency
                        amount
                      }
                    }
                  }
                }
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"customer_id": customer_id}
        response = await self.execute(
            query=query,
            operation_name="getCustomerCheckoutsByID",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetCustomerCheckoutsByID.model_validate(data)

    async def get_full_checkout_by_id(
        self, checkout_id: str, **kwargs: Any
    ) -> GetFullCheckoutByID:
        query = gql(
            """
            query getFullCheckoutByID($checkoutID: ID!) {
              checkout(id: $checkoutID) {
                id
                privateMetafields
                metafields
                created
                updatedAt
                lastChange
                customerNote
                note
                discountName
                translatedDiscountName
                email
                isShippingRequired
                quantity
                stockReservationExpires
                deliveryMethod {
                  __typename
                  ... on ShippingMethod {
                    id
                    privateMetafields
                    metafields
                    type
                    name
                    description
                    maximumDeliveryDays
                    minimumDeliveryDays
                    active
                    message
                  }
                }
                taxExemption
                token
                languageCode
                displayGrossPrices
                authorizeStatus
                chargeStatus
                channel {
                  id
                  slug
                  name
                }
                billingAddress {
                  id
                  privateMetafields
                  metafields
                  firstName
                  lastName
                  companyName
                  streetAddress1
                  streetAddress2
                  city
                  cityArea
                  postalCode
                  countryArea
                  phone
                  isDefaultShippingAddress
                  isDefaultBillingAddress
                  country {
                    code
                    country
                  }
                }
                shippingAddress {
                  id
                  privateMetafields
                  metafields
                  firstName
                  lastName
                  companyName
                  streetAddress1
                  streetAddress2
                  city
                  cityArea
                  postalCode
                  countryArea
                  phone
                  isDefaultShippingAddress
                  isDefaultBillingAddress
                  country {
                    code
                    country
                  }
                }
                availableShippingMethods {
                  id
                  privateMetafields
                  metafields
                  type
                  name
                  description
                  maximumDeliveryDays
                  minimumDeliveryDays
                  active
                  message
                  maximumOrderWeight {
                    unit
                    value
                  }
                  minimumOrderWeight {
                    unit
                    value
                  }
                  price {
                    currency
                    amount
                  }
                  maximumOrderPrice {
                    currency
                    amount
                  }
                  minimumOrderPrice {
                    currency
                    amount
                  }
                }
                availableCollectionPoints {
                  id
                  privateMetafields
                  metafields
                  name
                  slug
                  email
                  isPrivate
                  companyName
                  clickAndCollectOption
                  externalReference
                  address {
                    id
                    metafields
                    firstName
                    lastName
                    companyName
                    streetAddress1
                    streetAddress2
                    city
                    cityArea
                    postalCode
                    countryArea
                    phone
                    isDefaultShippingAddress
                    isDefaultBillingAddress
                    country {
                      code
                      country
                    }
                  }
                }
                lines {
                  id
                  privateMetafields
                  metafields
                  quantity
                  requiresShipping
                  problems {
                    __typename
                    ... on CheckoutLineProblemVariantNotAvailable {
                      line {
                        id
                        metafields
                        quantity
                        requiresShipping
                        isGift
                        variant {
                          id
                          metafields
                          name
                          sku
                          margin
                          quantityOrdered
                          quantityAvailable
                          created
                          updatedAt
                          externalReference
                        }
                      }
                    }
                  }
                  isGift
                  variant {
                    id
                    privateMetafields
                    metafields
                    name
                    sku
                    trackInventory
                    quantityLimitPerCustomer
                    channel
                    margin
                    quantityOrdered
                    quantityAvailable
                    created
                    updatedAt
                    externalReference
                    product {
                      id
                      privateMetafields
                      metafields
                      seoTitle
                      seoDescription
                      name
                      description
                      slug
                      created
                      updatedAt
                      chargeTaxes
                      rating
                      channel
                      descriptionJson
                      isAvailable
                      availableForPurchase
                      availableForPurchaseAt
                      isAvailableForPurchase
                      externalReference
                      productType {
                        id
                        privateMetafields
                        metafields
                        name
                        slug
                        hasVariants
                        isShippingRequired
                        isDigital
                        kind
                      }
                      thumbnail {
                        url
                        alt
                      }
                      weight {
                        unit
                        value
                      }
                    }
                    weight {
                      unit
                      value
                    }
                    channelListings {
                      id
                      margin
                      price {
                        currency
                        amount
                      }
                      channel {
                        metafields
                        slug
                        name
                        isActive
                        currencyCode
                        hasOrders
                      }
                    }
                  }
                  totalPrice {
                    currency
                    gross {
                      currency
                      amount
                    }
                  }
                }
                shippingPrice {
                  currency
                  gross {
                    currency
                    amount
                  }
                }
                totalPrice {
                  currency
                  gross {
                    currency
                    amount
                  }
                }
                shippingMethod {
                  id
                  privateMetafields
                  metafields
                  type
                  name
                  description
                  maximumDeliveryDays
                  minimumDeliveryDays
                  active
                  message
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"checkoutID": checkout_id}
        response = await self.execute(
            query=query,
            operation_name="getFullCheckoutByID",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetFullCheckoutByID.model_validate(data)

    async def get_order_by_id(self, order_id: str, **kwargs: Any) -> GetOrderByID:
        query = gql(
            """
            query getOrderByID($orderId: ID!) {
              order(id: $orderId) {
                created
                updatedAt
                status
                trackingClientId
                shippingMethodName
                collectionPointName
                actions
                number
                original
                origin
                isPaid
                paymentStatus
                paymentStatusDisplay
                authorizeStatus
                chargeStatus
                taxExemption
                shippingTaxClassName
                token
                voucherCode
                customerNote
                redirectUrl
                statusDisplay
                canFinalize
                userEmail
                isShippingRequired
                languageCode
                languageCodeEnum
                discountName
                translatedDiscountName
                displayGrossPrices
                externalReference
                checkoutId
                lines {
                  id
                  productName
                  variantName
                  productSku
                  productVariantId
                  isShippingRequired
                  quantity
                  quantityFulfilled
                  taxRate
                  unitDiscountReason
                  unitDiscountValue
                  unitDiscountType
                  isPriceOverridden
                  translatedProductName
                  translatedVariantName
                  saleId
                  quantityToFulfill
                  totalPrice {
                    currency
                    gross {
                      currency
                      amount
                    }
                  }
                }
                shippingPrice {
                  currency
                  gross {
                    currency
                    amount
                  }
                }
                total {
                  currency
                  gross {
                    currency
                    amount
                  }
                }
                channel {
                  id
                  slug
                  name
                  isActive
                  currencyCode
                  hasOrders
                }
                billingAddress {
                  id
                  firstName
                  lastName
                  companyName
                  streetAddress1
                  streetAddress2
                  city
                  cityArea
                  postalCode
                  countryArea
                  phone
                  isDefaultShippingAddress
                  isDefaultBillingAddress
                  country {
                    code
                    country
                  }
                }
                shippingAddress {
                  id
                  firstName
                  lastName
                  companyName
                  streetAddress1
                  streetAddress2
                  city
                  cityArea
                  postalCode
                  countryArea
                  phone
                  isDefaultShippingAddress
                  isDefaultBillingAddress
                  country {
                    code
                    country
                  }
                }
                metadata {
                  key
                  value
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"orderId": order_id}
        response = await self.execute(
            query=query, operation_name="getOrderByID", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetOrderByID.model_validate(data)

    async def get_order_list(
        self,
        sort_by: Union[Optional[OrderSortingInput], UnsetType] = UNSET,
        filter: Union[Optional[OrderFilterInput], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetOrderList:
        query = gql(
            """
            query getOrderList($sortBy: OrderSortingInput, $filter: OrderFilterInput, $before: String, $after: String, $first: Int, $last: Int) {
              orders(
                sortBy: $sortBy
                filter: $filter
                before: $before
                after: $after
                first: $first
                last: $last
              ) {
                totalCount
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
                edges {
                  cursor
                  node {
                    id
                    created
                    updatedAt
                    status
                    trackingClientId
                    shippingMethodName
                    collectionPointName
                    actions
                    number
                    original
                    origin
                    isPaid
                    paymentStatus
                    paymentStatusDisplay
                    authorizeStatus
                    chargeStatus
                    taxExemption
                    shippingTaxRate
                    shippingTaxClassName
                    token
                    redirectUrl
                    statusDisplay
                    canFinalize
                    userEmail
                    isShippingRequired
                    languageCode
                    languageCodeEnum
                    discountName
                    externalReference
                    checkoutId
                    total {
                      currency
                      gross {
                        currency
                        amount
                      }
                    }
                    metadata {
                      key
                      value
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "sortBy": sort_by,
            "filter": filter,
            "before": before,
            "after": after,
            "first": first,
            "last": last,
        }
        response = await self.execute(
            query=query, operation_name="getOrderList", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetOrderList.model_validate(data)

    async def get_product(self, id: str, **kwargs: Any) -> GetProduct:
        query = gql(
            """
            query GetProduct($id: ID!) {
              product(id: $id) {
                id
                name
                slug
                description
                variants {
                  id
                  name
                  sku
                  pricing {
                    price {
                      gross {
                        amount
                        currency
                      }
                    }
                  }
                  stocks {
                    quantity
                  }
                }
                metafields
              }
            }
            """
        )
        variables: Dict[str, object] = {"id": id}
        response = await self.execute(
            query=query, operation_name="GetProduct", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetProduct.model_validate(data)

    async def get_shipping_zone_info_by_id(
        self, sz_id: str, **kwargs: Any
    ) -> GetShippingZoneInfoByID:
        query = gql(
            """
            query getShippingZoneInfoByID($szID: ID!) {
              shippingZone(id: $szID) {
                id
                privateMetafields
                metafields
                name
                default
                description
                shippingMethods {
                  id
                  privateMetafields
                  metafields
                  name
                  description
                  type
                  maximumDeliveryDays
                  minimumDeliveryDays
                  maximumOrderPrice {
                    currency
                    amount
                  }
                  minimumOrderPrice {
                    currency
                    amount
                  }
                  channelListings {
                    id
                    channel {
                      id
                      name
                    }
                    maximumOrderPrice {
                      currency
                      amount
                    }
                    minimumOrderPrice {
                      currency
                      amount
                    }
                    price {
                      currency
                      amount
                    }
                  }
                }
                warehouses {
                  id
                  privateMetafields
                  metafields
                  name
                  slug
                  email
                  isPrivate
                  companyName
                  clickAndCollectOption
                  externalReference
                }
                channels {
                  id
                  slug
                  name
                  isActive
                  currencyCode
                  hasOrders
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"szID": sz_id}
        response = await self.execute(
            query=query,
            operation_name="getShippingZoneInfoByID",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetShippingZoneInfoByID.model_validate(data)

    async def get_warehouse_by_id(self, wh_id: str, **kwargs: Any) -> GetWarehouseByID:
        query = gql(
            """
            query getWarehouseByID($whID: ID!) {
              warehouse(id: $whID) {
                id
                privateMetafields
                metafields
                name
                slug
                email
                isPrivate
                companyName
                clickAndCollectOption
                externalReference
                address {
                  id
                  metafields
                  firstName
                  lastName
                  companyName
                  streetAddress1
                  streetAddress2
                  city
                  cityArea
                  postalCode
                  countryArea
                  phone
                  isDefaultShippingAddress
                  isDefaultBillingAddress
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"whID": wh_id}
        response = await self.execute(
            query=query,
            operation_name="getWarehouseByID",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetWarehouseByID.model_validate(data)

    async def get_warehouse_with_stocks(
        self,
        wh_id: str,
        before: Union[Optional[str], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetWarehouseWithStocks:
        query = gql(
            """
            query getWarehouseWithStocks($whID: ID!, $before: String, $after: String, $first: Int, $last: Int) {
              warehouse(id: $whID) {
                id
                privateMetafields
                metafields
                name
                slug
                email
                isPrivate
                companyName
                clickAndCollectOption
                externalReference
                address {
                  id
                  metafields
                  firstName
                  lastName
                  companyName
                  streetAddress1
                  streetAddress2
                  city
                  cityArea
                  postalCode
                  countryArea
                  phone
                  isDefaultShippingAddress
                  isDefaultBillingAddress
                }
                stocks(before: $before, after: $after, first: $first, last: $last) {
                  totalCount
                  pageInfo {
                    hasNextPage
                    hasPreviousPage
                    startCursor
                    endCursor
                  }
                  edges {
                    cursor
                    node {
                      id
                      quantity
                      quantityAllocated
                      quantityReserved
                      productVariant {
                        id
                        privateMetafields
                        metafields
                        name
                        sku
                        trackInventory
                        quantityLimitPerCustomer
                        channel
                        margin
                        quantityOrdered
                        quantityAvailable
                        created
                        updatedAt
                        externalReference
                        product {
                          id
                          privateMetafields
                          metafields
                          seoTitle
                          seoDescription
                          name
                          description
                          slug
                          created
                          updatedAt
                          chargeTaxes
                          rating
                          channel
                          descriptionJson
                          isAvailable
                          availableForPurchase
                          availableForPurchaseAt
                          isAvailableForPurchase
                          externalReference
                          productType {
                            id
                            privateMetafields
                            metafields
                            name
                            slug
                            hasVariants
                            isShippingRequired
                            isDigital
                            kind
                          }
                          category {
                            id
                            privateMetafields
                            metafields
                            seoTitle
                            seoDescription
                            name
                            description
                            slug
                            level
                            descriptionJson
                            updatedAt
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "whID": wh_id,
            "before": before,
            "after": after,
            "first": first,
            "last": last,
        }
        response = await self.execute(
            query=query,
            operation_name="getWarehouseWithStocks",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return GetWarehouseWithStocks.model_validate(data)

    async def get_warehouses(
        self,
        filter: Union[Optional[WarehouseFilterInput], UnsetType] = UNSET,
        sort_by: Union[Optional[WarehouseSortingInput], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> GetWarehouses:
        query = gql(
            """
            query getWarehouses($filter: WarehouseFilterInput, $sortBy: WarehouseSortingInput, $before: String, $after: String, $first: Int, $last: Int) {
              warehouses(
                filter: $filter
                sortBy: $sortBy
                before: $before
                after: $after
                first: $first
                last: $last
              ) {
                totalCount
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
                edges {
                  cursor
                  node {
                    id
                    privateMetafields
                    metafields
                    name
                    slug
                    email
                    isPrivate
                    companyName
                    clickAndCollectOption
                    externalReference
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "filter": filter,
            "sortBy": sort_by,
            "before": before,
            "after": after,
            "first": first,
            "last": last,
        }
        response = await self.execute(
            query=query, operation_name="getWarehouses", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return GetWarehouses.model_validate(data)

    async def list_products_by_merchant(
        self,
        first: Union[Optional[int], UnsetType] = UNSET,
        merchant_id: Union[Optional[str], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ListProductsByMerchant:
        query = gql(
            """
            query listProductsByMerchant($first: Int, $merchant_id: String, $after: String) {
              products(
                first: $first
                filter: {metadata: [{key: "merchant_id", value: $merchant_id}]}
                after: $after
              ) {
                totalCount
                edges {
                  cursor
                  node {
                    id
                    seoTitle
                    seoDescription
                    name
                    description
                    slug
                    created
                    updatedAt
                    chargeTaxes
                    rating
                    channel
                    descriptionJson
                    isAvailable
                    externalReference
                    category {
                      id
                      seoTitle
                      seoDescription
                      name
                      description
                      slug
                      level
                      descriptionJson
                      updatedAt
                    }
                    productType {
                      id
                      name
                      slug
                      hasVariants
                      isShippingRequired
                      isDigital
                    }
                    defaultVariant {
                      id
                      metadata {
                        key
                        value
                      }
                      name
                      sku
                      trackInventory
                      quantityLimitPerCustomer
                      channel
                      channelListings {
                        price {
                          currency
                          amount
                        }
                      }
                    }
                    variants {
                      id
                      metadata {
                        key
                        value
                      }
                      name
                      sku
                      channel
                      channelListings {
                        price {
                          currency
                          amount
                        }
                      }
                      media {
                        id
                        sortOrder
                        alt
                        type
                        oembedData
                        productId
                        metadata {
                          key
                          value
                        }
                        url
                      }
                    }
                    media {
                      id
                      sortOrder
                      alt
                      type
                      oembedData
                      url
                      productId
                    }
                  }
                }
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "first": first,
            "merchant_id": merchant_id,
            "after": after,
        }
        response = await self.execute(
            query=query,
            operation_name="listProductsByMerchant",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ListProductsByMerchant.model_validate(data)

    async def list_products_with_all_filters(
        self,
        filter: Union[Optional[ProductFilterInput], UnsetType] = UNSET,
        where: Union[Optional[ProductWhereInput], UnsetType] = UNSET,
        sort_by: Union[Optional[ProductOrder], UnsetType] = UNSET,
        search: Union[Optional[str], UnsetType] = UNSET,
        channel: Union[Optional[str], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ListProductsWithAllFilters:
        query = gql(
            """
            query listProductsWithAllFilters($filter: ProductFilterInput, $where: ProductWhereInput, $sortBy: ProductOrder, $search: String, $channel: String, $before: String, $after: String, $first: Int, $last: Int) {
              products(
                filter: $filter
                where: $where
                sortBy: $sortBy
                search: $search
                channel: $channel
                before: $before
                after: $after
                first: $first
                last: $last
              ) {
                totalCount
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
                edges {
                  cursor
                  node {
                    id
                    metafields
                    name
                    productType {
                      name
                    }
                    defaultVariant {
                      id
                      name
                      sku
                      channelListings {
                        price {
                          currency
                          amount
                        }
                      }
                    }
                    thumbnail {
                      url
                      alt
                    }
                    productVariants {
                      totalCount
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "filter": filter,
            "where": where,
            "sortBy": sort_by,
            "search": search,
            "channel": channel,
            "before": before,
            "after": after,
            "first": first,
            "last": last,
        }
        response = await self.execute(
            query=query,
            operation_name="listProductsWithAllFilters",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ListProductsWithAllFilters.model_validate(data)

    async def list_warehouses_by_i_ds(
        self,
        filter: Union[Optional[WarehouseFilterInput], UnsetType] = UNSET,
        sort_by: Union[Optional[WarehouseSortingInput], UnsetType] = UNSET,
        before: Union[Optional[str], UnsetType] = UNSET,
        after: Union[Optional[str], UnsetType] = UNSET,
        first: Union[Optional[int], UnsetType] = UNSET,
        last: Union[Optional[int], UnsetType] = UNSET,
        **kwargs: Any
    ) -> ListWarehousesByIDs:
        query = gql(
            """
            query listWarehousesByIDs($filter: WarehouseFilterInput, $sortBy: WarehouseSortingInput, $before: String, $after: String, $first: Int, $last: Int) {
              warehouses(
                filter: $filter
                sortBy: $sortBy
                before: $before
                after: $after
                first: $first
                last: $last
              ) {
                totalCount
                pageInfo {
                  hasNextPage
                  hasPreviousPage
                  startCursor
                  endCursor
                }
                edges {
                  cursor
                  node {
                    id
                    metafields
                    name
                    slug
                    email
                    isPrivate
                    companyName
                    clickAndCollectOption
                    externalReference
                    address {
                      id
                      firstName
                      lastName
                      companyName
                      streetAddress1
                      streetAddress2
                      city
                      cityArea
                      postalCode
                      countryArea
                      phone
                      isDefaultShippingAddress
                      isDefaultBillingAddress
                      country {
                        code
                        country
                      }
                    }
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "filter": filter,
            "sortBy": sort_by,
            "before": before,
            "after": after,
            "first": first,
            "last": last,
        }
        response = await self.execute(
            query=query,
            operation_name="listWarehousesByIDs",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return ListWarehousesByIDs.model_validate(data)

    async def update_shipping_zone(
        self,
        shipping_zone_id: str,
        name: Union[Optional[str], UnsetType] = UNSET,
        add_warehouses: Union[Optional[List[str]], UnsetType] = UNSET,
        remove_warehouses: Union[Optional[List[str]], UnsetType] = UNSET,
        **kwargs: Any
    ) -> UpdateShippingZone:
        query = gql(
            """
            mutation updateShippingZone($shippingZoneID: ID!, $name: String, $addWarehouses: [ID!], $removeWarehouses: [ID!]) {
              shippingZoneUpdate(
                id: $shippingZoneID
                input: {name: $name, addWarehouses: $addWarehouses, removeWarehouses: $removeWarehouses}
              ) {
                shippingErrors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                errors {
                  field
                  message
                  code
                  warehouses
                  channels
                }
                shippingZone {
                  id
                  privateMetafields
                  metafields
                  name
                  default
                  description
                  shippingMethods {
                    id
                    privateMetafields
                    metafields
                    name
                    description
                    type
                    maximumDeliveryDays
                    minimumDeliveryDays
                    maximumOrderPrice {
                      currency
                      amount
                    }
                    minimumOrderPrice {
                      currency
                      amount
                    }
                    minimumOrderWeight {
                      unit
                      value
                    }
                    maximumOrderWeight {
                      unit
                      value
                    }
                  }
                  warehouses {
                    id
                    privateMetafields
                    metafields
                    name
                    email
                    isPrivate
                    companyName
                    clickAndCollectOption
                    externalReference
                    slug
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "shippingZoneID": shipping_zone_id,
            "name": name,
            "addWarehouses": add_warehouses,
            "removeWarehouses": remove_warehouses,
        }
        response = await self.execute(
            query=query,
            operation_name="updateShippingZone",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateShippingZone.model_validate(data)

    async def order_confirm_from_merchant(
        self, order_id: str, **kwargs: Any
    ) -> OrderConfirmFromMerchant:
        query = gql(
            """
            mutation orderConfirmFromMerchant($orderId: ID!) {
              orderConfirm(id: $orderId) {
                order {
                  id
                  created
                  updatedAt
                  status
                  trackingClientId
                  shippingMethodName
                  collectionPointName
                  actions
                  number
                  original
                  origin
                  isPaid
                  paymentStatus
                  paymentStatusDisplay
                  authorizeStatus
                  chargeStatus
                  taxExemption
                  shippingTaxRate
                  shippingTaxClassName
                  token
                  voucherCode
                  customerNote
                  redirectUrl
                  statusDisplay
                  canFinalize
                  userEmail
                  isShippingRequired
                  languageCode
                  languageCodeEnum
                  discountName
                  translatedDiscountName
                  displayGrossPrices
                  externalReference
                  checkoutId
                  metafields
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"orderId": order_id}
        response = await self.execute(
            query=query,
            operation_name="orderConfirmFromMerchant",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return OrderConfirmFromMerchant.model_validate(data)

    async def create_variant_for_product(
        self,
        product_id: str,
        sku: Union[Optional[str], UnsetType] = UNSET,
        name: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> CreateVariantForProduct:
        query = gql(
            """
            mutation createVariantForProduct($product_id: ID!, $sku: String, $name: String) {
              productVariantCreate(
                input: {sku: $sku, name: $name, product: $product_id, trackInventory: false, attributes: []}
              ) {
                productErrors {
                  field
                  message
                  code
                  attributes
                  values
                }
                errors {
                  field
                  message
                  code
                  attributes
                  values
                }
                productVariant {
                  id
                  name
                  sku
                  trackInventory
                  quantityLimitPerCustomer
                  channel
                  margin
                  quantityOrdered
                  quantityAvailable
                  created
                  updatedAt
                  externalReference
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "product_id": product_id,
            "sku": sku,
            "name": name,
        }
        response = await self.execute(
            query=query,
            operation_name="createVariantForProduct",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return CreateVariantForProduct.model_validate(data)

    async def set_shipping_method_for_checkout(
        self, shipping_method: str, checkout_id: str, **kwargs: Any
    ) -> SetShippingMethodForCheckout:
        query = gql(
            """
            mutation setShippingMethodForCheckout($shippingMethod: ID!, $checkoutId: ID!) {
              checkoutShippingMethodUpdate(id: $checkoutId, shippingMethodId: $shippingMethod) {
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                checkout {
                  id
                  privateMetafields
                  metafields
                  created
                  updatedAt
                  lastChange
                  customerNote
                  note
                  discountName
                  translatedDiscountName
                  voucherCode
                  email
                  isShippingRequired
                  quantity
                  stockReservationExpires
                  deliveryMethod {
                    __typename
                    ... on ShippingMethod {
                      id
                      privateMetafields
                      metafields
                      type
                      name
                      description
                      maximumDeliveryDays
                      minimumDeliveryDays
                      active
                      message
                    }
                  }
                  taxExemption
                  token
                  languageCode
                  displayGrossPrices
                  authorizeStatus
                  chargeStatus
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "shippingMethod": shipping_method,
            "checkoutId": checkout_id,
        }
        response = await self.execute(
            query=query,
            operation_name="setShippingMethodForCheckout",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return SetShippingMethodForCheckout.model_validate(data)

    async def variant_set_price(
        self, variant_id: str, channel_id: str, price: Any, **kwargs: Any
    ) -> VariantSetPrice:
        query = gql(
            """
            mutation variantSetPrice($variantId: ID!, $channelId: ID!, $price: PositiveDecimal!) {
              productVariantChannelListingUpdate(
                input: {channelId: $channelId, price: $price}
                id: $variantId
              ) {
                productChannelListingErrors {
                  field
                  message
                  code
                  attributes
                  values
                  channels
                  variants
                }
                errors {
                  field
                  message
                  code
                  attributes
                  values
                  channels
                  variants
                }
                variant {
                  id
                  name
                  sku
                  trackInventory
                  quantityLimitPerCustomer
                  channel
                  margin
                  quantityOrdered
                  quantityAvailable
                  created
                  updatedAt
                  externalReference
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "variantId": variant_id,
            "channelId": channel_id,
            "price": price,
        }
        response = await self.execute(
            query=query, operation_name="variantSetPrice", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return VariantSetPrice.model_validate(data)

    async def update_checkout_addresses(
        self,
        city: str,
        country: CountryCode,
        checkout_id: str,
        street_1: Union[Optional[str], UnsetType] = UNSET,
        street_2: Union[Optional[str], UnsetType] = UNSET,
        validate: Union[Optional[bool], UnsetType] = UNSET,
        phone: Union[Optional[str], UnsetType] = UNSET,
        **kwargs: Any
    ) -> UpdateCheckoutAddresses:
        query = gql(
            """
            mutation updateCheckoutAddresses($city: String!, $country: CountryCode!, $street1: String, $street2: String, $validate: Boolean, $checkoutId: ID!, $phone: String) {
              checkoutBillingAddressUpdate(
                billingAddress: {city: $city, country: $country, streetAddress1: $street1, streetAddress2: $street2, skipValidation: $validate, phone: $phone}
                id: $checkoutId
              ) {
                errors {
                  field
                  message
                  code
                }
              }
              checkoutShippingAddressUpdate(
                shippingAddress: {city: $city, country: $country, streetAddress1: $street1, streetAddress2: $street2, skipValidation: $validate, phone: $phone}
                id: $checkoutId
              ) {
                errors {
                  field
                  message
                  code
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {
            "city": city,
            "country": country,
            "street1": street_1,
            "street2": street_2,
            "validate": validate,
            "checkoutId": checkout_id,
            "phone": phone,
        }
        response = await self.execute(
            query=query,
            operation_name="updateCheckoutAddresses",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateCheckoutAddresses.model_validate(data)

    async def update_checkout_email(
        self, email: str, checkout_id: str, **kwargs: Any
    ) -> UpdateCheckoutEmail:
        query = gql(
            """
            mutation updateCheckoutEmail($email: String!, $checkoutId: ID!) {
              checkoutEmailUpdate(email: $email, id: $checkoutId) {
                checkoutErrors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                errors {
                  field
                  message
                  code
                  variants
                  lines
                  addressType
                }
                checkout {
                  id
                  created
                  updatedAt
                  lastChange
                  customerNote
                  note
                  discountName
                  translatedDiscountName
                  voucherCode
                  email
                  isShippingRequired
                  quantity
                  stockReservationExpires
                  taxExemption
                  token
                  languageCode
                  displayGrossPrices
                  authorizeStatus
                  chargeStatus
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"email": email, "checkoutId": checkout_id}
        response = await self.execute(
            query=query,
            operation_name="updateCheckoutEmail",
            variables=variables,
            **kwargs
        )
        data = self.get_data(response)
        return UpdateCheckoutEmail.model_validate(data)

    async def update_warehouse(
        self, input: WarehouseUpdateInput, id: str, **kwargs: Any
    ) -> UpdateWarehouse:
        query = gql(
            """
            mutation UpdateWarehouse($input: WarehouseUpdateInput!, $id: ID!) {
              updateWarehouse(input: $input, id: $id) {
                errors {
                  field
                  message
                  code
                  shippingZones
                }
                warehouseErrors {
                  field
                  message
                  code
                  shippingZones
                }
                warehouse {
                  id
                  name
                  slug
                  email
                  isPrivate
                  companyName
                  clickAndCollectOption
                  externalReference
                  address {
                    id
                    companyName
                    streetAddress1
                    streetAddress2
                    city
                    cityArea
                    postalCode
                    countryArea
                    phone
                    isDefaultShippingAddress
                    isDefaultBillingAddress
                  }
                }
              }
            }
            """
        )
        variables: Dict[str, object] = {"input": input, "id": id}
        response = await self.execute(
            query=query, operation_name="UpdateWarehouse", variables=variables, **kwargs
        )
        data = self.get_data(response)
        return UpdateWarehouse.model_validate(data)
